
- 在JS中（V8引擎）中内存是由引擎的垃圾回收机制自动管理内容的
- V8在设计上默认对内存使用存在限制，只允许使用部分内存，64位系统可允许使用内存约1.4g，32位系统约0.7g
- V8的内存使用量查看方法

```js
process.memoryUsage();

// 返回内存的使用量，单位字节
{
  rss: 22953984,
  // 申请的总的堆内存
  heapTotal: 9682944,
  // 已使用的堆内存
  heapUsed: 5290344,
  external: 9388
}
```

![image](https://note.youdao.com/yws/res/21712/B1E9948264AA417F8AD55CB4AB12009B)

已申请的堆内存的未使用部分不够时，会继续申请堆内存，直到超出限制内存限制为止。

### V8限制堆内存大小原因

- V8最初为浏览器设计，该限制允许的内存以及足够，遇到大内存使用的场景较少
- 堆内存过大时，V8执行垃圾回收的时间较久（1.5g要50ms），做非增量式的垃圾回收要更久（1.5g要1s）

### 打开V8的内存上限

```bash
# 更改老生代的内存限制，单位mb
node --max-old-space-size=2048 index.js

# 更改新生代的内存限制，单位mb
node --max-semi-space-size=1024=64 index.js
```

这里需要注意的是更改的新生代的内存的语法已经更改为上述的写法，且单位也由`kb`变成了`mb`，老得写法是`node --max-new-space-size`，可以通过下面命令查询当前Node环境修改新生代内存的语法:

```bash
node --v8-options | grep max
```

![image](https://note.youdao.com/yws/res/21728/25D7430997C5465BBAB4F6DAB365AFE0)

### V8垃圾回收算法

在引擎的垃圾自动回收机制的历史演变中，人们发现是没有一种通用的可以解决任何场景下垃圾回收的算法的。因此现代垃圾回收算法根据对象的**存活时间**将内存垃圾进行**分代**，对不同类别的内存垃圾实行不同的回收算法。

V8将内存分为`新生代`和`老生代`两种：

- 新生代内存中的对象存活时间较短
- 老生代内存中代对象存活时间较长或是常驻内存

新生代内存存放在新生代内存空间（`semispace`）中，老生代内存存放在老生代内存空间中（`oldspace`）,如下图所示：

![image](https://note.youdao.com/yws/res/21750/D7D58CC2530E4E6CAA4672C9E7EFF4A2)

对于新生代内存的内存回收采用`Scavenge`算法，`Scavenge`的具体实现采用的是`Cheney`算法。`Cheney`算法是将新生代内存空间一分为二，一个空间处于使用状态（`FromSpace`），一个空间处于空闲状态（称为`ToSpace`）。

![image](https://note.youdao.com/yws/res/21767/8940B3F2742F4A22A7B1190112EE6448)

在内存开始分配时，首先在`FromSpace`中进行分配，垃圾回收机制执行时会检查`FromSpace`中的存活对象，存活对象会被会被复制到`ToSpace`，非存活对象所占用的空间将被释放，复制完成后`FromSpace`和`ToSpace`的角色将**翻转**。当一个对象多次复制后依然处于存活状态，则认为其是长期存活对象，此时将发生晋升，然后该对象被移动到老生代空间`oldSpace`中，采用新的算法进行管理。

`Scavenge`算法其实就是在两个空间内来回复制存活对象，是典型的空间换时间做法，所以非常适合新生代内存，因为仅复制存活的对象且新生代内存中存活对象是占少数的。

`晋升`的完成要符合两个条件：

- 对象是否经历过`Scavenge`回收
- `ToSpace`的内存使用占比不能超过限制

![image](https://note.youdao.com/yws/res/21796/1823317ADB4F44CD8A8A37E76F58E751)

老生代内存中，长期存活的对象较多，无法采取`Scavenge`算法回收的原因在于：

- 存活对象较多导致复制效率低下
- 浪费了一半的内存空间

因此在老生代内存空间的垃圾回收采用的是`标记清除`（Mark-Sweep）和`标记整理`（Mark-Compact）结合的方式。标记清除的做法是在标记阶段遍历老生代堆内存中的所有内存对象，并对活着的对象做标记，清除阶段只清理未被标记的对象。原因是：老生代内存中非存活对象占少数。

![image](https://note.youdao.com/yws/res/21814/E281F7A6257143668A4572ACB9AC1026)

如上图所示，标记清除存在的一个问题是清理之后存在了不连续的空间导致无法继续利用，所以对于老生代内存空间的内存清理需要结合标记整理的方案。该方案是在标记过程中将活着的对象往一侧移动，移动完成后再清理界外的所有非存活对象移除。

### 垃圾回收的暂停

垃圾回收时需要暂停应用执行逻辑，待垃圾回收机制结束后再恢复应用执行逻辑，该行为称为“全暂停”。对新生代内存的垃圾回收该行为对应用执行影响不大，但是老生代内存由于存活对象较多，所以老生代内存的垃圾回收造成的全停顿影响非常大。

V8的改善措施为将回收动作进行以`增量标记`的方式进行拆解，每完成一步就让js应用逻辑执行一会，交替的方式往前行。增量标记的方式可以使原来停顿的最大时间减少到原本的`1/6`。

V8还引入了延迟清理和增量式整理的方案让清理逻辑也变成增量式的，同时引入并行标记与并行清理，进一步利用多核减少停顿时间。

### 减少垃圾回收的影响

想要提高执行效率要尽量减少垃圾回收的执行和消耗：

- 避免使用内存存储用户会话，否则在内存中存放大量用户会话对象导致老生代内存激增，影响清理性能进而影响应用执行性能和内存溢出。改进方式使用使用redis等。将缓存转移到外部的好处：
    - 减少常驻内存对象的数量，垃圾回收更高效
    - 进程之间可以共享缓存
- 慎把内存当作缓存，小心把对象当作缓存，要合理限制过期时间和无限增长的问题，可以采用lru策略

### 突破V8内存限制

Node的内存构成一部分由V8进行分配，一部分由Node自行分配。

- 使用Bufer对象