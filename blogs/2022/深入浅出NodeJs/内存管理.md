- 在JS中（V8引擎）中内存是由引擎的垃圾回收机制自动管理内容的
- V8在设计上默认对内存使用存在限制，只允许使用部分内存，64位系统可允许使用内存约1.4g，32位系统约0.7g
- V8的内存使用量查看方法

```js
process.memoryUsage();

// 返回内存的使用量，单位字节
{
  rss: 22953984,
  // 申请的总的堆内存
  heapTotal: 9682944,
  // 已使用的堆内存
  heapUsed: 5290344,
  external: 9388
}
```

![image](https://note.youdao.com/yws/res/21712/B1E9948264AA417F8AD55CB4AB12009B)

已申请的堆内存的未使用部分不够时，会继续申请堆内存，直到超出限制内存限制为止。

### V8限制堆内存大小原因

- V8最初为浏览器设计，该限制允许的内存以及足够，遇到大内存使用的场景较少
- 堆内存过大时，V8执行垃圾回收的时间较久（1.5g要50ms），做非增量式的垃圾回收要更久（1.5g要1s）

### 打开V8的内存上限

```bash
# 更改老生代的内存限制，单位mb
node --max-old-space-size=2048 index.js

# 更改新生代的内存限制，单位mb
node --max-semi-space-size=1024=64 index.js
```

这里需要注意的是更改的新生代的内存的语法已经更改为上述的写法，且单位也由`kb`变成了`mb`，老得写法是`node --max-new-space-size`，可以通过下面命令查询当前Node环境修改新生代内存的语法:

```bash
node --v8-options | grep max
```

![image](https://note.youdao.com/yws/res/21728/25D7430997C5465BBAB4F6DAB365AFE0)

### V8垃圾回收算法

在引擎的垃圾自动回收机制的历史演变中，人们发现是没有一种通用的可以解决任何场景下垃圾回收的算法的。因此现代垃圾回收算法根据对象的**存活时间**将内存垃圾进行**分代**，对不同类别的内存垃圾实行不同的回收算法。

V8将内存分为`新生代`和`老生代`两种：

- 新生代内存中的对象存活时间较短
- 老生代内存中代对象存活时间较长或是常驻内存

新生代内存存放在新生代内存空间（`semispace`）中，老生代内存存放在老生代内存空间中（`oldspace`）,如下图所示：

![image](https://note.youdao.com/yws/res/21750/D7D58CC2530E4E6CAA4672C9E7EFF4A2)

对于新生代内存的内存回收采用`Scavenge`算法，`Scavenge`的具体实现采用的是`Cheney`算法。`Cheney`算法是将新生代内存空间一分为二，一个空间处于使用状态（`FromSpace`），一个空间处于空闲状态（称为`ToSpace`）。

![image](https://note.youdao.com/yws/res/21767/8940B3F2742F4A22A7B1190112EE6448)

在内存开始分配时，首先在`FromSpace`中进行分配，垃圾回收机制执行时会检查`FromSpace`中的存活对象，存活对象会被会被复制到`ToSpace`，非存活对象所占用的空间将被释放，复制完成后`FromSpace`和`ToSpace`的角色将**翻转**。当一个对象多次复制后依然处于存活状态，则认为其是长期存活对象，此时将发生晋升，然后该对象被移动到老生代空间`oldSpace`中，采用新的算法进行管理。

`Scavenge`算法其实就是在两个空间内来回复制存活对象，是典型的空间换时间做法，所以非常适合新生代内存，因为仅复制存活的对象且新生代内存中存活对象是占少数的。

`晋升`的完成要符合两个条件：

- 对象是否经历过`Scavenge`回收
- `ToSpace`的内存使用占比不能超过限制

![image](https://note.youdao.com/yws/res/21793/079D1E421C7F4B46805C26A85999AFCF)

